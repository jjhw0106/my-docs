# 📅 26년 1월 25일 (스크래퍼 서버 작업)

---

### ✅ 1. 데이터 모델 개선 (Schema Update & MongoDB Flexibility)
**목표:** 다중 사용자 및 멀티 플랫폼 지원을 위해 데이터 식별 구조를 개선한다.

*   **`ApplyHistory` 스키마 수정**:
    *   `appUserId` (String): 우리 서비스(My Backoffice)의 유저 식별자 필드 추가.
    *   `platformUserId` (String): 기존 `userId` 필드의 역할을 명확히 재정의.
*   **NoSQL의 장점 활용**:
    *   RDBMS였다면 `ALTER TABLE` 등 복잡한 마이그레이션 과정이 필요했겠지만, MongoDB(NoSQL)의 유연한 스키마(Schema-less) 특성 덕분에 별도의 DB 작업 없이 코드 레벨에서 `appUserId` 필드를 추가하고 즉시 적용할 수 있었다.

### ✅ 2. 비즈니스 로직 리팩토링 및 버그 수정 (`ScraperService`)
**목표:** 스키마 변경에 맞춰 저장, 삭제, 조회 로직을 `appUserId` 기준으로 전면 수정하고, 데이터 중복 적재 문제를 해결한다.

*   **`deleteMany` 오동작 해결 (중복 데이터 방지)**:
    *   **문제**: 기존 로직은 `deleteMany({ userId: ... })`로 삭제를 시도했으나, 해당 필드 매핑이 정확하지 않아 삭제 쿼리가 동작하지 않음. 이로 인해 스크래핑할 때마다 데이터가 지워지지 않고 계속 쌓이는(Append) 현상 발생.
    *   **해결**: 삭제 조건을 `appUserId`와 `platform`의 조합으로 명확히 지정(`deleteMany({ appUserId, platform })`)하여, 새로운 데이터를 저장하기 전에 기존 데이터를 확실하게 제거하도록 수정. 이제 스크래핑 시 항상 최신 데이터 상태(Replace)를 유지함.
*   **`saveScrapedData` 리팩토링**:
    *   필드 매핑: 프론트엔드에서 받은 `appUserId`는 DB의 `appUserId`로, `credentials.id`는 DB의 `platformUserId`로 정확히 매핑하여 저장.
*   **`getApplyHistory` (조회)**:
    *   `appUserId`를 기준으로 조회 쿼리를 변경하여, 사용자가 연동한 모든 플랫폼의 지원 내역을 한 번에 불러올 수 있도록 개선.

### ✅ 3. 컨트롤러 확장 (`ScraperController`)
*   **`POST /scraper/:platform`**:
    *   기존: `id`, `pw`만 받음.
    *   변경: 요청 `Body` 전체를 서비스 레이어로 전달하여, `appUserId` 등 추가적인 메타데이터를 유연하게 처리할 수 있도록 확장.

---

### 💭 트러블슈팅
*   **`ValidationError: platformUserId is required`**: 스키마에는 `platformUserId`가 필수인데, 서비스 코드에서 `userId`라는 이름으로 데이터를 넣으려다 발생한 에러. 서비스 코드의 매핑 로직을 `platformUserId: credentials.id`로 수정하여 해결.
*   **조회 결과 0건 문제**: 프론트엔드는 `platformUserId`를 보내고 백엔드는 `appUserId`로 검색하려다 발생한 불일치. 프론트엔드 로직을 수정하여 `appUserId`를 보내도록 통일함.
