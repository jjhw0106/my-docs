# 📅 2026년 1월 3일 작업 리포트 (With GEMINI)

## 📝 개요 (Summary)
금일은 스크래퍼 서버의 데이터 영속성(Persistence) 확보를 위해 **MongoDB(Atlas)**를 도입하였다. NestJS 환경에서 Mongoose를 효율적으로 사용하기 위한 패턴을 학습하고, 실제 클라우드 DB와의 연결 및 저장 로직을 검증하는 통합 테스트(Integration Test)를 구현하였다.

---

## 🏗 1. MongoDB 연동 프로세스 (Connection Process)

NestJS 서버와 MongoDB Atlas를 연결하기 위해 다음과 같은 단계적인 절차를 수행하였다.

1.  **패키지 설치**:
    - `@nestjs/mongoose`: NestJS용 Mongoose 래퍼.
    - `mongoose`: 실제 ODM 라이브러리.
    - `@nestjs/config`: 환경 변수(`.env`) 관리를 위한 모듈.
2.  **환경 변수 구성**:
    - **중요**: `.env` 파일은 `src/` 내부가 아닌 **프로젝트 루트(`package.json` 위치)**에 위치해야 `ConfigModule`이 인식함.
    - `MONGODB_URI`에 Atlas 연결 문자열(Connection String) 및 DB명(`mybo_db`) 설정.
3.  **모듈 설정 (`AppModule`)**:
    - `ConfigModule.forRoot()`: 환경 변수 로드.
    - `MongooseModule.forRoot()`: 로드된 URI를 사용하여 DB 연결 초기화.

---

## 📚 2. 학습: NestJS Mongoose 문법 및 패턴

NestJS에서 Mongoose를 다룰 때 사용되는 데코레이터와 디자인 패턴에 대해 정리하였다.

| 문법 / 요소 | 코드 예시 | 역할 및 의미 |
| :--- | :--- | :--- |
| **@Schema()** | `@Schema({ timestamps: true })` | 해당 클래스가 MongoDB의 **문서(Document) 설계도**임을 선언. 옵션을 통해 `createdAt` 등 자동 관리. |
| **@Prop()** | `@Prop({ required: true })` | 클래스의 프로퍼티를 DB의 **필드(Field)**로 정의. 타입 검증 및 제약 조건 설정. |
| **SchemaFactory** | `SchemaFactory.createForClass(T)` | TypeScript로 작성된 클래스를 Mongoose가 이해하는 **실제 스키마 객체로 변환**해주는 팩토리 메서드. |
| **@InjectModel()** | `@InjectModel(ApplyHistory.name)` | **의존성 주입(DI)**. 서비스(Service)가 직접 DB 모델을 생성하지 않고, 모듈로부터 주입받아 사용하도록 요청. |
| **Class.name** | `ApplyHistory.name` | 매직 스트링(Magic String, 예: "ApplyHistory") 대신 클래스명을 사용하여 오타 방지 및 리팩토링 안전성 확보. |

---

## 🧪 3. 테스트 코드 및 동작 플로우 (Integration Test)

단순 유닛 테스트가 아닌, **실제 DB와 통신**하는 통합 테스트(`scraper.service.spec.ts`)를 작성하여 데이터 저장 기능을 검증하였다.

### 🔄 테스트 동작 플로우
1.  **BeforeAll (환경 구성)**:
    - `Test.createTestingModule`을 통해 가상 모듈을 생성.
    - `ConfigModule`과 `MongooseModule`을 실제와 동일하게 로드하여 **MongoDB Atlas에 접속**.
    - `ApplyHistory` 스키마를 등록하여 테스트용 모델 생성.
2.  **Test Execution (검증 수행)**:
    - **Clean Up**: `deleteMany`로 테스트 사용자(`test_user`)의 기존 데이터를 삭제하여 **멱등성(Idempotency)** 확보.
    - **Action**: `create()` 메서드로 더미 데이터를 DB에 저장.
    - **Verify**: `findOne()`으로 저장된 데이터를 다시 조회하여 필드값(`company`, `position` 등) 일치 여부 검증.
3.  **AfterAll (자원 해제)**:
    - `module.close()`를 호출하여 테스트 종료 후 DB 연결을 안전하게 끊음.

---

## 🏗 4. 아키텍처 리팩토링: 관심사의 분리 (SoC)

기존에 `scrapeJobKorea` 메서드에 섞여 있던 스크래핑 로직과 저장 로직을 분리하고, **퍼사드 패턴(Facade Pattern)**을 적용하여 구조를 개선하였다.

### 🧐 고민: 비즈니스 로직의 조립은 어디서 해야 하는가? (Controller vs Service)
- **컨트롤러 조립안**: 서비스는 순수 기능만 제공하고 컨트롤러가 흐름을 제어. 서비스 간 결합도는 낮아지나 비즈니스 규칙(스크랩 시 반드시 저장)이 컨트롤러로 유출됨.
- **서비스 조립안 (채택)**: 서비스 내부에 `scrapePlatform`이라는 관문(Facade)을 두어 전체 워크플로우를 제어. 캡슐화와 응집도가 높아지며, 다른 채널(예: 스케줄러)에서 호출 시에도 동일한 규칙 보장.

### 🛠 리팩토링 결과: 단일 책임 원칙(SRP) 강화
1.  **`scrapeJobKorea`**: 순수하게 브라우저를 조작하여 Raw 데이터 리스트만 추출 및 반환.
2.  **`saveScrapedData`**: 추출된 플랫폼별 데이터를 DB 스키마(`ApplyHistory`)에 맞게 매핑하고 영속화 수행.
3.  **`scrapePlatform`**: 위 두 과정을 순차적으로 실행하는 오케스트레이터 역할.

---

## 🔍 5. 조회 기능 구현 및 로직 최적화 (Read & Refactoring)

### 1) 조회 API 구현
- **Endpoint**: `GET /scraper/history/:userId`
- **로직**: MongoDB의 `find()` 메서드와 `sort({ appliedAt: -1 })`를 조합하여 사용자의 지원 내역을 최신순으로 반환하도록 구현.

### 2) 식별자 로직 최적화
- **아이디 통일**: 스크래핑 시 사용하는 로그인 ID(`id`)를 시스템 내부의 사용자 식별자(`userId`)와 동일시하도록 로직을 통합.
- **파라미터 간소화**: 서비스 메서드 인자에서 중복되는 `userId`를 제거하고 `credentials` 객체에서 직접 추출하여 사용함으로써 코드 가독성 향상.

---

## 📂 변경된 파일 목록 (File Changes)

```text
scraper-server/
├── .env                                         # MongoDB 연결 정보
├── src/
│   ├── main.ts                                  # CORS 허용 설정
│   └── scraper/
│       ├── schemas/
│       │   └── apply-history.schema.ts          # 지원 내역 스키마 정의
│       ├── scraper.controller.ts                # POST(스크랩), GET(조회) API
│       └── scraper.service.ts                   # Facade 패턴 기반 스크랩/저장/조회 로직
```
